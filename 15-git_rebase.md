В GIT есть два способа внести изменения из одной ветки в другую: ***слияние (merge)***  и ***перебазирование (rebase)*** .

С помощью команды rebase вы можете взять все изменения, которые были зафиксированы (commited) в одной ветке и применить их к другой ветке.

Это работает следующим образом: берется общий родительский снимок (snapshot) двух веток (той, в которой вы находитесь, и той, поверх которой вы выполняете перебазирование); берется дельта (diff) каждого коммита той ветки, на который вы находитесь, эти дельты сохраняются во временные файлы; текущая ветка устанавливается на тот же коммит, что и ветка, поверх которой вы выполняете перебазирование; и, наконец, ранее сохраненные дельты применяются поочереди.

***К примеру, нам надо перенести изменения из develop в master:***
```
git checkout experiment
git rebase master
```
***При запуске команды rebase мы должны находиться в той ветке, которую хотим применить, а не в которую хотим. Не так как при merge, а наоборот***
Это работает следующим образом: берется общий родительский снимок (snapshot) двух веток (той, в которой вы находитесь, и той, поверх которой вы выполняете перебазирование); берется дельта (diff) каждого коммита той ветки, на который вы находитесь, эти дельты сохраняются во временные файлы; текущая ветка устанавливается на тот же коммит, что и ветка, поверх которой вы выполняете перебазирование; и, наконец, ранее сохраненные дельты применяются поочереди.
  ![rebase-1.png](pic/rebase-1.png)
  
 На этом моменте вы можете переключиться обратно на ветку master и выполнить слияние перемоткой.
 ```
 git checkout master
 git merge experiment
 ```
 Вот что получится:
 ![rebase-2.png](pic/rebase-2.png)
 
Нет абсолютно никакой разницы в конечном результате между merge и rebase, но перебазирование делает историю коммитов чище. Если вы взглянете на историю перебазированной ветки, то увидите, что она выглядит абсолютно линейной: будто все операции были выполнены последовательно, даже если изначально они совершались параллельно.

Перебазирование повторяет изменения из одной ветки поверх другой в порядке, в котором эти изменения были представлены, в то время как слияние берет две конечные точки и сливает их вместе.

***Выполнение rebase без перехода в нужную ветку:***
```
git rebase master server
```
будет выполнен перенос коммитов из ветки `server` на `master`.

### Более сложный случай:
Также возможно сделать так, чтобы при перемещении воспроизведение коммитов начиналось не от той ветки, на которую делается перемещение. Возьмём, например, Историю разработки с тематической веткой, ответвлённой от другой тематической ветки. Вы создаете тематическую ветку (server), чтобы добавить в проект некоторые функциональности для серверной части, и делаете коммит. Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и несколько раз выполнили коммиты. Наконец, вы вернулись на ветку server и сделали ещё несколько коммитов.
![rebase-3.png](pic/rebase-3.png)

Предположим, вы решили, что хотите внести свои изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части до полного тестирования. Вы можете взять изменения из ветки `client`, которых нет в server (C8 и C9), и применить их на ветке `master` при помощи опции `--onto` команды `git rebase`:
```
git rebase --onto master server client
```
Это прямое указание “переключиться на ветку `client`, то есть взять изменения от общего предка веток `client` и `server` и повторить их на `master`”. Несмотря на некоторую сложность этого способа, результат впечатляет:
![rebase-4.png](pic/rebase-4.png)

Теперь вы можете выполнить перемотку (fast-forward) для ветки `master`:
```
git checkout master
git merge client
```
![rebase-5.png](pic/rebase-5.png)

### Преимущества rebase
1. Позволяет держать историю коммитов чище
2. Когда контрибъютим в чужой проект, чтобы владельцу было меньше работы

### Недостатки rebase
1. Если будет применен rebase уже топравленным на удаленный сервер и скачанные кем-то, может быть большая путаница и проблемы.
